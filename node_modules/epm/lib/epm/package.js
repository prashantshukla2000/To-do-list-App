/*!
 * This file is part of EPM.
 *
 * please see the LICENSE
 */

'use strict'

var crypto = require('crypto'),
  fs = require('fs-extra'),
  path = require('path'),
  async = require('async'),
  zlib = require('zlib'),
  MemoryStream = require('../utils/memory-stream'),
  _ = require('underscore')

var PACKAGE_VERSION = 1

/**
 * 
 * Initialize a new Package instance with `ops`.
 *
 * @param {Object} ops
 */
var Package = module.exports = function (ops) {
  var self = this

  if (false === (self instanceof Package)) {
    return new Package()
  }

  ops = ops || {}

  // The format package version
  self.packageVersion = PACKAGE_VERSION

  self.version = ops.version || 1
  self.uid = self.generateUid()
  self.metadata = ops.metadata || {}

  self.files = []

  return self
}

/**
 * 
 * Generate a unique id
 *
 */
Package.prototype.generateUid = function () {
  var toHash = (new Date()).valueOf().toString() + Math.random().toString()

  return crypto
    .createHash('md5')
    .update(toHash)
    .digest('hex')
}

/**
 * 
 * Set metadata
 *
 */
Package.prototype.setMetadata = function (metadata) {
  var self = this

  self.metadata = metadata

  return self
}

/**
 * 
 * Add entry file/directory
 *
 */
Package.prototype.addEntry = function (entry, cb) {
  var self = this

  if (!fs.existsSync(entry)) {
    return cb(new Error('Unknown file'))
  }

  async.waterfall([
    function (cb) {
      fs.stat(entry, cb)
    },
    function (stat, cb) {
      // stat.isFile()
      // stat.isDirectory()
      if (stat.isFile()) {
        self.files.push({
          name: path.basename(entry),
          stat: stat,
          fullname: path.resolve(entry)
        })
        cb()
      } else if (stat.isDirectory()) {
        var items = []
        var rpath = path.resolve(entry)

        fs.walk(entry)
          .on('data', function (item) {
            if (item.stats.isFile()) {
              self.files.push({
                name: item.path.replace(rpath, ''),
                stat: item.stats,
                fullname: path.resolve(item.path)
              })
            }
          })
          .on('end', function () {
            cb()
          })
      }
    }

  ], function (err, results) {
    cb(null)
  })

  return self
}

/**
 * 
 * Get current header
 *
 */
Package.prototype._getHeader = function () {
  var self = this

  return {
    version: self.version,
    uid: self.uid,
    metadata: self.metadata,
    files: {}
  }
}

/**
 * 
 * Pack the package a save as `output`
 *
 */
Package.prototype.pack = function (output, callback) {
  var self = this

  async.waterfall([
    function (cb) {
      var proccesed = []
      var q = async.queue(function (file, qcb) {
        var ms = new MemoryStream()

        ms.on('finish', function (result) {
          proccesed.push({
            file: file,
            buffer: ms.buffer
          })

          qcb()
        })

        var inp = fs.createReadStream(file.fullname)
        var gzip = zlib.createGzip()

        inp.pipe(gzip).pipe(ms)
      }, 1)

      q.drain = function () {
        cb(null, proccesed)
      }

      q.push(self.files)
    },
    function (proccesed, cb) {
      var header = self._getHeader()

      var index = 0
      proccesed.forEach(function (item) {
        header.files[index++] = {
          file: item.file.name,
          length: item.buffer.length
        }
      })

      // write header
      var vbuff = Buffer.alloc(2)
      vbuff.writeUInt16BE(self.version)

      var strheader = JSON.stringify(header)

      var lbuff = Buffer.alloc(4)
      lbuff.writeUInt32BE(Buffer.byteLength(strheader))

      var mbuff = Buffer.alloc(Buffer.byteLength(strheader))
      mbuff.write(strheader)

      var ws = fs.createWriteStream(path.resolve(output))

      ws.write(vbuff)
      ws.write(lbuff)
      ws.write(mbuff)

      proccesed.forEach(function (item) {
        ws.write(item.buffer)
      })

      ws.end()
      cb()
    }
  ], function (err) {
    if (err) { callback(err) }

    callback(null)
  })

  return self
}

Package.prototype.readMetadata = function (filename, callback) {
  var self = this

  if (!fs.existsSync(filename)) {
    callback(new Error('Unknown filename `' + filename + '`'))
  }

  async.waterfall([
    function (cb) {
      fs.open(path.resolve(filename), 'r', cb)
    },
    function (fd, cb) {
      let buff = Buffer.alloc(2)

      fs.read(fd, buff, 0, 2, 0, function (err, bytesRead, buffer) {
        var version = buffer.readUInt16BE(0)
        cb(err, fd, version)
      })
    },
    function (fd, v, cb) {
      let buff = Buffer.alloc(4)

      fs.read(fd, buff, 0, 4, 2, function (err, bytesRead, buffer) {
        var contentLength = buffer.readUInt32BE(0)
        cb(err, fd, v, contentLength)
      })
    },
    function (fd, v, cl, cb) {
      let buff = Buffer.alloc(cl)

      fs.read(fd, buff, 0, cl, 6, function (err, bytesRead, buffer) {
        var mm = buffer.toString()

        var info = {
          fd: fd,
          version: v,
          contentLength: cl,
          meta: JSON.parse(mm)
        }

        cb(err, info)
      })
    }
  ], function (err, info) {
    fs.close(info.fd)

    if (err) { return callback(err); }

    callback(null, info.meta)
  })
}

/**
 * 
 * Unpack the package `filename` on `destination` folder
 *
 */
Package.prototype.unpack = function (filename, destination, callback) {
  var self = this

  if (!fs.existsSync(destination)) {
    callback(new Error('Unknown destination `' + output + '`'))
  }

  if (!fs.statSync(destination).isDirectory()) {
    callback(new Error('Destination `' + output + '` is not a directory'))
  }

  async.waterfall([
    function (cb) {
      fs.open(path.resolve(filename), 'r', cb)
    },
    function (fd, cb) {
      let buff = Buffer.alloc(2)

      fs.read(fd, buff, 0, 2, 0, function (err, bytesRead, buffer) {
        var version = buffer.readUInt16BE(0)
        cb(err, fd, version)
      })
    },
    function (fd, v, cb) {
      let buff = Buffer.alloc(4)

      fs.read(fd, buff, 0, 4, 2, function (err, bytesRead, buffer) {
        var contentLength = buffer.readUInt32BE(0)
        cb(err, fd, v, contentLength)
      })
    },
    function (fd, v, cl, cb) {
      let buff = Buffer.alloc(cl)
      fs.read(fd, buff, 0, cl, 6, function (err, bytesRead, buffer) {
        var mm = buffer.toString()
        var info = {
          fd: fd,
          version: v,
          contentLength: cl,
          meta: JSON.parse(mm)
        }

        cb(err, info)
      })
    },
    function (info, cb) {
      var toProccess = []
      var pointer = info.contentLength + 2 + 4

      Object
        .keys(info.meta.files)
        .forEach(function (key) {
          var f = info.meta.files[key]

          toProccess.push({
            key: key,
            name: f.file,
            init: pointer,
            length: f.length
          })

          pointer = pointer + f.length
        })

      var q = async.queue(function (file, qcb) {
        var fd = info.fd

        let buff = Buffer.alloc(file.length)
        fs.read(fd, buff, 0, file.length, file.init, function (err, bytesRead, buffer) {
          var out = path.join(path.resolve(destination), file.name)
          let inp = fs.createWriteStream(out)

          zlib
            .gunzip(buffer, function (err, stream) {
              if (err) {
                return callback(err)
              }

              inp.write(stream)
              inp.end()
              console.log(out + ' writed')
              qcb(null)
            })
        })
      }, 1)

      q.drain = function () {
        cb(null, info)
      }

      q.push(toProccess)
    }
  ], function (err, info) {
    fs.close(info.fd)

    if (err) { return callback(err); }

    callback(null, info)
  })

  return self;
}

Package.prototype.getEntry = function (filename, entry, callback) {
  var self = this;

  async.waterfall([
    function (cb) {
      fs.open(path.resolve(filename), 'r', cb)
    },
    function (fd, cb) {
      let buff = Buffer.alloc(2)

      fs.read(fd, buff, 0, 2, 0, function (err, bytesRead, buffer) {
        var version = buffer.readUInt16BE(0)
        cb(err, fd, version)
      })
    },
    function (fd, v, cb) {
      let buff = Buffer.alloc(4)

      fs.read(fd, buff, 0, 4, 2, function (err, bytesRead, buffer) {
        var contentLength = buffer.readUInt32BE(0)
        cb(err, fd, v, contentLength)
      })
    },
    function (fd, v, cl, cb) {
      let buff = Buffer.alloc(cl)
      fs.read(fd, buff, 0, cl, 6, function (err, bytesRead, buffer) {
        var mm = buffer.toString()
        var info = {
          fd: fd,
          version: v,
          contentLength: cl,
          meta: JSON.parse(mm)
        }

        cb(err, info)
      })
    },
    function (info, cb) {
      var toProccess = []
      var pointer = info.contentLength + 2 + 4;
      var files = {};
      var fd = info.fd
      

      Object
        .keys(info.meta.files)
        .forEach(function (key) {
          var f = info.meta.files[key]

          files[f.file] = {
            key: key,
            name: f.file,
            init: pointer,
            length: f.length
          }

          pointer = pointer + f.length
        })
        
      var file = files[entry]
      let buff = Buffer.alloc(file.length)

      fs.read(fd, buff, 0, file.length, file.init, function (err, bytesRead, buffer) {

        cb(null,info, buffer)
      })
    }
  ], function (err, info, buffer) {
    fs.close(info.fd)

    if (err) { return callback(err); }

    callback(null, buffer)
  })

  return self;
};